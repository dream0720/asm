## 一、打印 9x9 乘法表

### **概述**： 

这部分代码使用过程调用的方式来生成并显示 9x9 乘法表。行数和列数分别代表乘数和被乘数，结果以表格形式输出。代码中主要使用了 `MUL` 指令进行乘法计算，同时通过栈保存和恢复寄存器的值，确保循环过程中的数据不会被覆盖。

### 代码解析

1. **数据段定义**：
   - `prompt` 字符串用于在输出结果前显示表格的标题。

   ```assembly
   DATA SEGMENT
       prompt DB 'The 9x9 Multiplication Table:$'
       ; 其他数据段定义省略...
   DATA ENDS
   ```

2. **设置并输出提示信息**：
   - 通过 `MOV AX, DATA` 和 `MOV DS, AX` 设置数据段寄存器。
   - 使用中断 `21H` 功能号 `9` 输出 `prompt` 字符串作为标题。

3. **外层循环和内层循环**：
   - `CX` 和 `DX` 寄存器分别代表当前的行号和列号。在嵌套的过程调用中，代码将它们压入栈中，以保护当前的行列值。
   - **栈的使用**：
     - 每次循环迭代时，用 `PUSH` 将 `CX` 和 `DX` 压入栈，调用结束后通过 `POP` 恢复它们的值，保证在 `preoutput` 和 `PRINT_NUMBER` 调用中不会丢失行列的信息。

   ```assembly
   outLOOP:
       ; 保存当前行号 CX
       PUSH CX
       MOV DX, 1
   ```

4. **乘法计算**：
   - 使用 `MOV AX, CX` 将行号放入 `AX`，然后 `MUL DX` 计算乘积。结果的低位存储在 `AX`，高位存储在 `DX`。
   - **注意**：由于 `MUL` 会修改 `DX`，而 `DX` 表示列号，因此在 `MUL` 之后要恢复 `DX`，以免破坏列的值。

5. **格式化输出（调用子程序）**：
   - `preoutput` 子程序格式化输出，显示为 `row x column =` 的形式。
   - `PRINT_NUMBER` 用于输出乘积结果，通过计算每位数字并压入栈，之后按正确的顺序弹出栈，来显示正确的数字顺序。

6. **行列重置**：
   - `resetCol` 标签用于重置 `DX` 并递增 `CX`，以便进入下一行的计算。

7. **显示数字的栈操作**：
   - 在 `PRINT_NUMBER` 中，不断将 `AX` 进行除法取余，获取每一位数字，然后依次压入栈，最后按正确顺序从栈中弹出并显示。

### 代码截图：

![99](..\assets\99.png)

## 二、检查 9x9 乘法表的正确性

### **概述**：

这一部分代码通过遍历预定义的 9x9 乘法表数组（`table`），逐项检查表中是否存储了正确的乘积值。如果有不匹配的情况，会输出错误提示。

### 代码解析

1. **数据段定义**：
   - `table` 数组包含了预定义的乘法表结果。
   - `error` 和 `accomplish` 字符串用于输出错误和完成信息。

   ```assembly
   DATA SEGMENT
       table DW 1, 2, 3, ..., 81
       error DB 'Error at: ', '$'
       accomplish DB 'Accomplish!', '$'
   DATA ENDS
   ```

2. **循环结构**：
   - 和第一部分类似，`CX` 表示行，`DX` 表示列。
   - `SI` 用作数组索引，每次循环自增，用于遍历 `table` 数组中的值。

3. **乘法计算与对比**：
   - 每次循环计算当前行和列的乘积，然后与 `table` 数组中的值进行对比。
   - 如果不匹配，就跳转到 `errorOutput` 进行错误输出。

4. **错误信息输出**：
   - `errorOutput` 输出出错的行和列号。
   - **栈操作**：
     - 在错误检查和输出的过程中，用 `PUSH` 和 `POP` 保护和恢复 `CX` 和 `DX` 的值，以确保循环变量不会被覆盖。

5. **完成信息输出**：
   - 如果所有值都匹配，输出 `Accomplish!` 表示完成验证。

6. **PRINT_NUMBER 子程序**：
   - `PRINT_NUMBER` 子程序逻辑与第一部分相同，通过栈操作提取和显示数字。

### 代码截图：

![wrong99](..\assets\wrong99.png)

## 三、关键点

- **寄存器保护**：代码中通过 `PUSH` 和 `POP` 频繁保护 `CX` 和 `DX`，确保过程调用期间行列信息不会被覆盖。

- **PRINT_NUMBER 中的栈操作**：
   
   由于 `PRINT_NUMBER` 需要按正确的顺序输出数字，它会将每一位压入栈，然后再从栈中弹出，确保显示顺序正确。

## 四、陷阱

- `MUL`**的隐藏操作：**

  由于`AX DX`寄存器都是16位的，所以`MUL DX`在进行乘法操作时的结果是32位的，结果的低16位被存入`AX`，高16位被存入`DX`，因此需要保存`DX`的值，然后恢复。

  ```assembly
  	PUSH DX
      ; 计算乘法
      MOV AX, CX
      MUL DX             ; AX = CX * DX
      POP DX             ;MUL把结果的高16位放在了DX里，所以要从栈中恢复DX值
  ```

  