## 一、题目要求

假设某公司历年发展信息如下：

程序中数据已定义好，如下：

```assembly
data segment
    ; 以下是表示 21 年的 21 个字符串
    db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
    db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
    db '1993','1994','1995'

    ; 以下是表示 21 年公司总收入的 21 个 dword 型数据
    dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
    
    ; 以下是表示 21 年公司雇员人数的 21 个 word 型数据
    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
    dw 11542,14430,15257,17800

data ends

table segment
    db 21 dup ('year summ ne ?? ')    ; 每条记录16字节
table ends
```

### 编程要求

1. 将 data 段中的数据写入 table 段，并计算每年的人均收入（取整），结果一并填入下表所示的 table 段。
2. 将 table 段的数据打印出来，格式参照下图。
3. 要求引用多个文件。

## 二、代码实现

*主程序文件 `1.asm`:*

#### 1. 初始化段寄存器和栈：

- 初始化 SS 和 SP 寄存器，设置栈段。
- 初始化 DS 和 ES 寄存器，分别指向 data 段和 table 段。

#### 2.数据处理：

- 使用循环将 data 段中的年份、收入和雇员人数复制到 table 段。
- 计算每年的总收入除以雇员人数，得到人均收入，并将结果存储在 table 段。

#### 3.清屏操作：

- 使用 BIOS 中断 int 10h 清屏，设置背景为黑色，文字为灰色。

#### 4.数据显示：

- 初始化视频段，将 table 段的数据逐行显示在屏幕上。
- 使用外部过程 show_num 显示收入、雇员人数和人均收入。

------

*显示子程序文件 `display.asm`*

#### 5.显示数字的子程序 show_num：

- 保存寄存器状态。
- 将数字逐位使用除法转换为ASCII字符，并设置显示属性（绿色）。
- 将字符写入显存，显示在屏幕上。
- 恢复寄存器状态。

## 三、关键操作

1. #### 直接修改显存输出格式化字符

```assembly
  mov ax, 0B800H
  mov es, ax      ; es指向显存
  show_digit:
    pop dx              ; 取出数字
    add dl, 30h         ; 转ASCII
    mov dh, 03h         ; 设置绿色属性
    mov es:[si], dx     ; 写入显存
    add si, 2           ; 移动显存指针
    loop show_digit     ; 循环显示
```

​	先将es指向显存，然后直接在显存的相应位置输出。

​	具体的背景和前景颜色设置是通过将属性值存储在 `dh` 和 `dl` 中。前景颜色和背景颜色的设置	是基于字符属性值的，每个值有 4 位表示前景颜色和 4 位表示背景颜色。例如：

- 前景颜色的位：`00`=黑色, `01`=蓝色, `02`=绿色, `03`=浅绿色, `04`=红色, `05`=紫色, `06`=黄色, `07`=白色。
- 背景颜色的位：与前景颜色类似，用 4 位表示背景的颜色。

2. #### 使用不会溢出的除法转换双字为字符（重点）

   在使用`div`时，会把`DX:AX`作为被除数，然后把商放在`AX`里，把余数放在`DX`里，但是如果商大于16位，那么高位就会被覆盖掉，可以看到，如果直接使用`div cx`，输出超过16位的数的时候，实际上输出的是**该数关于65536取模的数字**，所以并不能直接使用`div`处理，而是应该使用一个商不会溢出的除法：

   ```assembly
   divdw:
   	push bx
   
   	push ax
   	mov ax, dx	;高16位
   	mov dx, 0
   	div cx		;除数
   	mov bx, ax	;bx = int(H/N)	dx = rem(H/N)
   	pop ax		;低16位
   	div cx		;(rem(H / N) * 10000H + L ) / N
   	mov cx, dx	;余数
   	mov dx, bx	;dx = int(H/N)
   
   	pop bx
   	ret
   ```

   这个代码非常巧妙的避免了商的溢出，首先计算了高16位的除法，把商保留，余数从`ax`放到`dx`里，相当于右移四位，然后把低16位的被除数放回`ax`里，这样再次计算除法的时候，被除数是高16位对于10取模的数*65536，加上低16位的数，通过证明可以得知，这个数应该小于等于65536x9+65535，除以10之后保证不高于16位，然后这个时候再把高16位的商放回高16位，这样就得到了被保存完好的商，以及一个余数！

3. #### 设置外部调用

   ```assembly
   ;1.asm
   extrn show_num:proc   ; 声明外部过程
   
   ;dis.asm
   ; 声明需要对外公开的过程
   public show_num
   ```

​	只需要添加两个声明即可。

